Library ieee;
use ieee_std_logic_1164.all;
use iee.std_logic_unsigned.all;
use ieee.numeric_std.all;

entity ALU
	port(
	Clock: in std_logic;
	A, B: in unsigned(7 downto 0);
	student_id: in unsigned(3 downto 0);
	OP: in unsigned(15 downto 0);
	Neg: out std_logic;
	R1: out unsigned(3 downto 0);
	R2: out unsigned(3 downto 0)
	);
end ALU;

architecture calculation of ALU is
	signal Reg1, Reg2, Result: unsigned(7 down to 0):=(others=>'0');
	signal Reg4: unsigned(7 downto 0);
	begin
		Reg1 <= A;
		Reg2 <= B;
	
	process(Clock, OP)
	begin
		if(rising_edge(Clock)) THEN
			
			case OP is
				when "0000000000000001" =>
					Result <= (Reg1 - Reg2);
					Neg <= '0'
					
				when "0000000000000010" =>
					if Reg1 > Reg2 then	-- Checs if subtraction results in positive or negative number
						Result <= (Reg1 - Reg2);
						Neg <= '0';
					else
						Result <= (Reg2 - Reg1);
						Neg <= '1';
					end if;
				
				when "0000000000000100" =>
				
					Result <= (NOT Reg1);
					Neg <= '0';
					
					
				when "0000000000001000" =>
					
					Result <= (Reg1 NAND Reg2);
					Neg <= '0';
				
				when "0000000000010000" =>
					
					Result <= (Reg1 NOR Reg2);
					Neg <= '0';
					
				
				when "0000000000100000" =>
					
					Result <= (Reg1 AND Reg2);
					Neg <= '0'
					
				when "0000000001000000" =>
					
					Result <= (Reg1 OR Reg2);
					Neg <= '0';
				
				when "0000000010000000" =>
				
					Result <= (Reg1 XOR Reg2);
					Neg <= '0';
				
				when "0000000100000000" =>
				
					Result <= (Reg1 XNOR Reg2);
					Neg <= '0';
					
				when others =>
				-- Don't care do nothing
			
			end case;
		end if;
	end process;
	
	R2 <= Result(3 downto 0); -- Since the seven segment can only hold 4 bits 
	R2 <= Result(7 downto 4); -- at a time split the 8-bit into two 4-bits

end calculation;
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
				